# Power Apps プロパティ選択不具合に関する調査レポート

## 1. 事象の概要
数式入力バーで数式を編集した後、ピン留めされた異なるコントロールのプロパティを選択しようとすると、コントロールの切り替え自体は成功するが、プロパティの選択（コンボボックスの切り替え）が機能しなくなる。

## 2. 再現手順
1. フローティングパネルを起動する
2. ツリービューからControlAを選択する
3. パネルのプロパティリストからControlA.PropertyAを開く
4. ControlA.PropertyAをピン留めする
5. ControlA.PropertyBを開く
6. ピンからControlA.PropertyAに戻る
7. ピン留めしてあったControlB.PropertyAをピンから開く
8. ピンからControlA.PropertyAに戻る
9. ControlA.PropertyAの式を編集する
10. ピンからControlB.PropertyAを開こうとすると、コントロールの選択はできているがプロパティの選択ができない

## 3. 原因の仮説と分析（当初）
数式編集直後（Monacoエディタにフォーカスがある状態）でコントロールの移動（ピン留めのクリックなど）を行うと、Power Apps（Fluent UI）側で変更のコミットとUIの再描画（Reactによる非同期レンダリング）が走ります。
この再描画のタイミングで、プロパティを選択するためのドロップダウン（コンボボックス）要素が一度DOMから破棄（デタッチ）され、再生成されます。
拡張機能側は、再生成される前の古いDOM要素を掴んだまま操作しようとしたり、再生成のタイミングと操作のタイミングが競合することで、UIイベントがPower Apps側に正常に認識されない（または操作が空振りする）状態になっています。

## 4. これまでに試した修正アプローチと結果

### アプローチ1: イベント発火タイミングの遅延・確実化
- **内容:** コンボボックスに一回フォーカスした後、再取得前に待機時間を延長（100ms → 200ms）し、`mousedown` / `mouseup` などのイベントを追加発火。
- **結果:** 失敗。単なる待機時間の延長やマウスイベントの追加では、消滅した古い要素に対する操作を完全に回避できず機能しなかった。

### アプローチ2: DOM要素の再取得と値の直接代入（Reactプロパティ更新ハック）
- **内容:** UIの再描画を待機（300ms）したあとに再度要素を `getElementById` で取得し直す。ドロップダウンの展開をシミュレートする代わりに、内部の `<input>` に対してネイティブセッターで強制的にプロパティ名を代入し、`input` -> `change` -> `Enterキー` を連続発火させて確定させる。
- **結果:** 失敗。入力欄の文字は変わるものの、プロパティは実際には切り替わらなかった（選択肢が開閉するまでの動作しか行われず、Reactの内部State更新条件を完全には満たせなかった）。

### アプローチ3: フォーカス関連処理の部分削除（切り分けテスト）
- **内容:** `handlePropertySelect` 処理の直後にある、「プロパティ選択完了後に再度Monacoエディタにフォーカスを戻す」処理を削除。フォーカスの取り合いが原因であるかを切り分けた。
- **結果:** 失敗。現象に変化なし。事後のフォーカス移動が原因ではないことが判明。

### アプローチ4: 複数回のリトライ・ループ構造の導入（ポーリング）
- **内容:** DOMの再構築のタイミングずれに対し、コンボボックスのフォーカス→取得→展開→要素検索→クリック という一連の流れを最大5回ループし、途中で要素がデタッチされたら最初からやり直す堅牢なリトライ方式を実装（※DOM安定や別プロパティ表示への対策）。
- **結果:** 失敗。根本解決に至らず、ユーザーの指示によりアプローチごと一旦ロールバック・破棄。

---

## 5. 根本原因の特定（Chrome DevTools Protocol による実機調査）

Chrome リモートデバッグ（CDP）を用いてPower Apps Studio の実際のDOMを直接調査したところ、仮説とは異なる2つの独立した根本原因が判明した。

### 根本原因1（主因）: `waitForListbox` が空のプレースホルダー要素を掴んでいた

Fluent UI v9 では、プロパティコンボボックスを開くと DOM 上に **2つの `[role="listbox"]` 要素**が存在する状態になる。

| 要素 | 存在タイミング | オプション数 |
|---|---|---|
| 空のプレースホルダー | 常にDOMに存在 | **0件** |
| 実際のリストボックス（`#fluent-listbox21` 等） | コンボを開いた時のみ | **38件** |

`document.querySelector('[role="listbox"]')` は DOM 順で**最初の要素（空のプレースホルダー）を常に返す**。`waitForListbox` はこの空要素を即座に「発見済み」として返すため、その後のオプション検索が常に0件となり、プロパティ選択が必ず失敗していた。

この問題はタイミングとは無関係であり、タイミング系のハック（リトライ・ディレイ）がすべて失敗した理由はここにある。

**修正:** `waitForListbox` にコンボボックス要素を渡し、その `aria-controls` 属性が指す ID のリストボックスを優先的に取得するよう変更。`aria-controls` がなければ `[role="option"]` を持つリストボックスを検索するフォールバックも追加。

### 根本原因2（副因）: `waitForControlSelected` が常に1500msタイムアウトしていた

`waitForControlSelected` は `[role="treeitem"][aria-selected="true"]` の出現を待つ実装だったが、現在のPower Apps Studio ではツリーアイテムに `aria-selected` が設定されない。そのため毎回1500msのタイムアウト待機が発生し、その間にコンボボックスの状態が中途半端なものを掴む余地が生じていた。

実測では、ツリーアイテムクリック後 **約123ms** でサイドバーヘッダーとコンボボックスの両方が新しいコントロールの内容に更新されることが確認された。

**修正:** サイドバーヘッダー（`#control-sidebar-header-control-name`）のテキスト変化を検出条件として追加。これにより実質的な待機時間が1500ms → 約123msに短縮された。

### 副次対応: `waitForSidebarReflectsControl` の追加

`handlePinSelect` において `selectControl()` と `selectProperty()` の間に、サイドバーが新しいコントロールを反映するまで待機するステップを追加。根本原因1・2の修正により実質的な待機はほぼ発生しないが、将来の Power Apps 側の変更に対する安全網として残置。

---

## 6. 解決済み

上記の修正により、数式編集後のプロパティ選択が正常に動作することを確認。レスポンスも改善。
